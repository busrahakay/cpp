% -*- coding: utf-8 -*-

\documentclass[compress]{beamer}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage{color}
\usepackage{listings}

\input{beamer.tex}
\input{listings.tex}

\begin{document}

%************************************************************************

\title{Referencje}

\author{dr inż.~Ireneusz Szcześniak}

\date{jesień 2017 roku}

\begin{frame}[plain]
  \titlepage
\end{frame}

%************************************************************************

\section{Wprowadzenie}

\subsection{Referencje}

\begin{frame}

  \frametitle{Referencje}

  \begin{itemize}
  \item \emph{Referencja} jest aliasem (inną nazwą) obiektu.
  \item Składnia referencji jest taka sama, jak nazwy obiektu.
  \item \red{Referencja musi być zainicjalizowana}, nie ma referencji
    ``pustych'', jak puste wskaźniki.
  \item \red{Referencji nie można zmienić}, żeby wskazać inny obiekt,
    tak jak wskaźnik.
  \item Można tworzyć pary (\code{std::pair}) i krotki
    (\code{std::tuple}) referencji, ale już nie kontenery czy tablice.
  \item Referencja nie zawsze ma miejsce w pamięci, bo może być
    wyoptymalizowana w czasie kompilacji.
  \item Główne zastosowanie:
    \begin{itemize}
    \item przekazywanie argumentów wywołania funkcji przez referencję,
    \item zwracanie wartości funkcji przez referencję,
    \item pola składowe klasy.
    \end{itemize}
  \end{itemize}

\end{frame}

%************************************************************************

\section{Szczegóły}

\subsection{Typy referencji}

\begin{frame}

  \frametitle{Typy referencji}

  \begin{itemize}
  \item \code{T &} - referencja typu \red{l-wartość}: służy do
    wskazania obiektu, który możemy modyfikować, ale \red{nie
      przenosić}, zakładając, że ten obiekt będzie później używany,
  \item \code{const T &} - referencja stała typu \red{l-wartość}:
    służy do wskazania obiektu, którego nie możemy modyfikować ani
    przenosić,
  \item \code{T &&} - referencja typu \red{r-wartość}: służy do
    wskazania obiektu, który możemy modifikować i \red{przenosić},
    zakładając, że ten obiekt wkrótce zostanie zniszczony.
  \end{itemize}

  \vspace{0.25 cm}

  Nazwy skrócone:
  \begin{itemize}
  \item \red{l-referencja} to referencja typu l-wartość,
  \item \red{r-referencja} to referencja typy r-wartość.
  \end{itemize}

\end{frame}

%************************************************************************

\subsection{Terminy l-wartość i r-wartość w nazwie typu}

\begin{frame}

  \frametitle{Terminy l-wartość i r-wartość w nazwie typu}

  \begin{itemize}

  \item Terminy l-wartość i r-wartość określają kategorię wartości
    wyrażenia:

    \begin{itemize}

    \item wyrażenie \code{"1"} ma kategorię l-wartość,

    \item wyrażenie \code{1} ma kategorię r-wartość.

    \end{itemize}

  \item Ale słowa te mogą też definiować typ referencji:

    \begin{itemize}

    \item \code{int &x;} - wyrażenie \code{x} ma typ ``referencja typu
      l-wartość'' i kategorię l-wartość,

    \item \code{int &&x;} - wyrażenie \code{x} ma typ ``referencja
      typu r-wartość'' i kategorię l-wartość.

    \end{itemize}

  \end{itemize}

  \vspace{0.5 cm}
  
  \red{TERAZ ROZUMIEM: Even if the variable's type is rvalue
    reference, the expression consisting of its name is an lvalue
    expression.}
  
\end{frame}

%************************************************************************

\subsection{L-referencja}

\begin{frame}

  \frametitle{L-referencja}

  L-referencja wskazuje l-wartość, a nie może wskazać r-wartości.

  \vspace{0.5 cm}
  
  L-referencję definiujemy z użyciem \code{&}: \code{T &}

  \vspace{0.5 cm}

  Jeżeli mamy funkcję \code{int &foo()}, to wyrażenie \code{foo()}
  jest \red{l-wartością}, dlatego tak można zainicjalizować
  l-referencję: \code{int &z = foo();}

\end{frame}

%************************************************************************

\subsection{L-referencja - przykłady}

\begin{frame}[fragile]

  \frametitle{L-referencja - przykłady}

\begin{lstlisting}
int x = 1;
int y = 2;

// BŁĄD: brak inicjalizacji.
int &a;

// OK, raz na zawsze zainicjalizowane.
int &z = x;

// Wskaźnik na referencję to wskaźnik na obiekt.
assert(&z == &x);

// To nie jest reinicjalizacja!
z = y;
\end{lstlisting}
  
\end{frame}

%************************************************************************

\subsection{Stała l-referencja do r-wartości}

\begin{frame}

  \frametitle{Stała l-referencja do r-wartości}

  \red{To nie jest r-referencja!}

  \vspace{0.5cm}

  Zasada wprowadzona w C++98, która obowiązuje do dzisiaj:
  \begin{itemize}
  \item stała l-referencja może wskazywać l-wartość lub \red{r-wartość}.
  \end{itemize}

  \vspace{0.5cm}

  Po angielsku: \red{const lvalue reference to rvalue}

  \vspace{0.5cm}

  Kwalifikator \code{const} odnosi się do wskazywanego obiektu (to
  obiekt jest stały), a nie referencja, bo referencji i tak nie można
  zmienić.

\end{frame}

%************************************************************************

\subsection{Stała l-referencja do r-wartości - przykłady}

\begin{frame}

  \frametitle{Stała l-referencja do r-wartości - przykłady}

  \begin{itemize}
  \item \code{int \&a = 1;} nie będzie się kompilować, bo 1 jest
    r-wartością i chcemy ją wskazać niestałą l-referencją,
  \item \code{const int \&b = 1;} będzie się kompilować, bo r-wartość
    wskazujemy stałą l-referencją,
  \item \code{int foo();} - deklaracja funkcji
  \item \code{const int &c = foo();} - OK!
  \item \code{const int *p = &foo();} - błąd!
  \item \code{const int *p = &c;} - OK!
  \end{itemize}

\end{frame}

%************************************************************************

\subsection{R-referencja}

\begin{frame}

  \frametitle{R-referencja}

  R-referencja wskazuje r-wartość, a nie może wskazać l-wartości.

  \vspace{0.5 cm}
  
  R-referencję definiujemy z użyciem \code{&&}: \code{T &&}

  \vspace{0.5 cm}

  To nowość wprowadzona w C++11, żeby umożliwić:

  \begin{itemize}
  \item mechanizm przenoszenia obiektów,
  \item doskonałe przekazywanie argumentów funkcji.
  \end{itemize}

  \vspace{0.5cm}

\end{frame}

%************************************************************************

\subsection{R-referencja - przykłady}

\begin{frame}[fragile]

  \frametitle{R-referencja - przykłady}

\begin{lstlisting}
int x = 1;

// BŁĄD: brak inicjalizacji.
int &&a;

// BŁĄD: nie może wskazać l-wartości.
int &&z = x;

// OK: wskazujemy r-wartość.
int &&z = 1;
\end{lstlisting}
  
\end{frame}

%************************************************************************

\subsection{R-referencja do l-wartości}

\begin{frame}[fragile]

  \frametitle{R-referencja do l-wartości}

  Możemy uzyskać r-referencję do l-wartości z użyciem operatora
  \code{static_cast<T &&>(expr)} lub funkcji \code{std::move(expr)},
  gdzie \code{expr} może być l-wartością albo r-wartością.  Funkcja
  \code{std::move} jest szablonowa i kompilator sam wnioskuje typ
  wyrażenia, którego nie trzeba już podawać, jak dla
  \code{static_cast}.  Na przykład:

  {\tiny\lstinputlisting{move.cc}}

  Funkcji \code{std::move(x)} będziemy używać, aby umożliwić
  przenoszenie obiektu \code{x}, dla którego domyślnie przenoszenie
  nie jest stosowane, ponieważ wyrażenie \code{x} jest l-wartością.

\end{frame}

%************************************************************************

\subsection{Przeciążanie funkcji a referencje}

\begin{frame}[fragile]

  \frametitle{Przeciążanie funkcji a referencje}

  Funkcję można przeciążyć różnymi typami referencyjnymi:

  \begin{enumerate}
  \item \code{void foo(T &);}
  \item \code{void foo(const T &);}
  \item \code{void foo(T &&);}
  \end{enumerate}

  Dla wywołania funkcji \code{foo(expr)}, kompilator wybierze:

  \begin{itemize}
    \item przeciążenie nr 1, jeżeli \code{expr} jest l-wartością typu
      niestałego,
    \item przeciążenie nr 2, jeżeli \code{expr} jest l-wartością typu
      stałego,
    \item przeciążenie nr 3, jeżeli \code{expr} jest r-wartością.
  \end{itemize}

  Stała l-referencja (użyta w przeciążeniu nr 2) może wskazać
  l-wartość typu niestałego lub r-wartość, więc jeżeli nie ma
  przeciążenia nr 1 lub 3, kompilator wybierze przeciążenie nr 2.

\end{frame}

%************************************************************************

\subsection{Wiązanie obiektu tymczasowego przez referencję}

\begin{frame}[fragile]

  \frametitle{Wiązanie obiektu tymczasowego przez referencję}

  Jeżeli obiekt tymczasowy jest wskazywany przez referencję, to jest
  on niszczony wtedy, kiedy referencja wychodzi poza \red{zakres}
  (ang.~scope).  Inaczej obiekt byłby niszczony po opracowaniu
  wyrażenia.

  \vspace{0.25 cm}

\begin{lstlisting}
// Obiekt tymczasowy T() jest niszczony
// wtedy, kiedy t1 wychodzi poza zakres.
const T &t1 = T();

// To samo, ale dla r-referencji.
T &&t2 = T();
\end{lstlisting}

  \vspace{0.25 cm}

  Nazywa się to \red{wiązaniem} obiektu tymczasowego przez referencję.

\end{frame}

%************************************************************************

\section{Koniec}

\subsection{Podsumowanie}

\begin{frame}

  \frametitle{Podsumowanie}

  \begin{itemize}
  \item Referencja to inna nazwa obiektu.
  \item Referencję trzeba zainicjalizować.
  \item Wartości referencji (wskazywanego obiektu) nie można zmienić.
  \item Podstawowe typy referencji:
    \begin{itemize}
    \item l-referencja,
    \item r-referencja.
    \end{itemize}
  \item Niestała l-referencja może wskazać l-wartość, ale nie r-wartość.
  \item Stała l-referencja może wskazywać l-wartość lub r-wartość.
  \item R-referencja może wskazywać r-wartość, ale nie l-wartość.
  \item Stała r-referencja nie ma sensu.
  \item Referencje wiążą obiekty tymczasowe.
  \end{itemize}

\end{frame}

%************************************************************************

\subsection{Dziękuję}

\begin{frame}[plain]

  \begin{center}
    \huge Dziękuję za uwagę.
  \end{center}

\end{frame}

\end{document}

%************************************************************************
%************************************************************************
%************************************************************************
%************************************************************************
%************************************************************************
%************************************************************************
%************************************************************************
%************************************************************************
%************************************************************************
%************************************************************************
%************************************************************************
%************************************************************************
%************************************************************************

\section{}

\begin{frame}

  \frametitle{}

  \begin{itemize}
  \item
  \end{itemize}

\end{frame}
