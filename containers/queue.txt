0. Stworzyć plik functor.cc i dodać regułę do Makefile.

1. Napisać program, który dodaje liczby całkowite do kolejki
   priorytetowej, a potem kolejno je pobiera i wypisuje na stdout.

#include <cassert>
#include <iostream>
#include <queue>

using namespace std;

int
main(void)
{
  priority_queue<int> q;

  q.push(2);
  q.push(1);
  q.push(3);

  while(!q.empty())
    {
      cout << q.top() << endl;
      q.pop();
    }
  
  return 0;
}

*********************************************************************

2. Domyślnie kolejka zwraca największy element.  Zdefiniować kolejkę,
   która będzie zwracać najmniejszy element.

   priority_queue<int, vector<int>, greater<int>> q;
  
*********************************************************************

3. Zdefiniować strukturę A, która ma tylko pole typu "string".  Dodać
   obiekty tej struktury do kolejki i też wypisać na stdout.

#include <cassert>
#include <iostream>
#include <queue>

using namespace std;

struct A
{
  A(const string &text): m_text(text) {}
  string m_text;
};

bool operator < (const A &e1, const A &e2)
{
  return e1.m_text < e2.m_text;
}

int
main(void)
{
  priority_queue<A> q;

  q.push(A("a2"));
  q.push(A("a0"));
  q.push(A("a1"));

  while(!q.empty())
    {
      cout << q.top().m_text << endl;
      q.pop();
    }
  
  return 0;
}

*********************************************************************

4. Kolejkę priorytetową obiektów klasy A sortować w odwrotnym
   kierunku niż w poprzednim zadaniu.

   priority_queue<A, vector<A>, greater<A>> q;

   bool operator > (const A &e1, const A &e2)
   {
     return e1.m_text > e2.m_text;
   }

*********************************************************************

5. Porównanie obiektów struktury A załatwić funktorem.  Funktor
   powinien przyjmować w konstruktorze parametr typu logicznego, który
   mówi, jak sortować obiekty: false - od największych do
   najmniejszych, true - od najmniejszych do największych.

#include <iostream>
#include <queue>
#include <vector>

using namespace std;

struct A
{
  A(const string &text): m_text(text) {}
  string m_text;
};

struct CMP
{
  bool m_order;
  CMP(bool order): m_order(order) {}
  bool operator () (const A &e1, const A &e2)
  {
    bool s = e1.m_text < e2.m_text;
    return m_order ? !s : s;
  }
};

int
main(void)
{
  priority_queue<A, vector<A>, CMP> q(CMP(true));

  q.push(A("a2"));
  q.push(A("a0"));
  q.push(A("a1"));

  while(!q.empty())
    {
      cout << q.top().m_text << endl;
      q.pop();
    }
  
  return 0;
}
