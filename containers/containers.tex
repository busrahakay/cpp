% -*- coding: utf-8 -*-

\documentclass[compress]{beamer}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage{color}
\usepackage{verbatim}
\usepackage{listings}

\lstset{language=[ISO]C++}

\hypersetup{pdfpagemode=FullScreen}

\useinnertheme{circles}
\useoutertheme[subsection = false, footline = pages]{irek}
\setbeamercolor{separation line}{use=structure,bg=structure.fg!50!bg}

% Turn off the navigation symbols.
\setbeamertemplate{navigation symbols}{}

\title{Kontenery}

\author{dr inż.~Ireneusz Szcześniak}

\date{jesień 2017 roku}

\newcommand{\red}[1]{\textcolor{red}{#1}}
\newcommand{\code}[1]{\texttt{\red{#1}}}

\begin{document}

%************************************************************************

\begin{frame}[plain]
  \titlepage
\end{frame}

%************************************************************************

\section{Wprowadzenie}

\subsection{Kontenery}

\begin{frame}

  \frametitle{Kontenery}

  \begin{itemize}
  \item Kontener w C++ to \emph{generyczna} struktura danych.
  \item Przechowuje elementy jednego dowolnego typu.
  \item Nie pozwala na mieszanie przechowywanych typów.
  \item Kontenery przechowują elementy przez wartość.
  \item Części komplementarne: \emph{iterator, algorytm}.
  \item Kontenery są implementowane przez klasy szablonowe.
  \end{itemize}

\end{frame}

%************************************************************************

\subsection{Historia}

\begin{frame}

  \frametitle{Historia}

  \begin{itemize}
  \item Kiedyś (początek lat 90.):
    \begin{itemize}
    \item nowość, kierunek badań naukowych,
    \item implementacja jako Standard Template Library (STL).
    \end{itemize}
  \item Teraz:
    \begin{itemize}
    \item niezbędne narzędzie,
    \item w bibliotece standardowej od C++98.
    \end{itemize}
  \item Nie ma wymówki: \red{trzeba używać.}
  \item Ale czasami trzeba użyć czegoś innego w starym (legacy)
    kodzie.
  \end{itemize}

\end{frame}

%************************************************************************

\section{Kontenery}

\subsection{Typy kontenerów}

\begin{frame}

  \frametitle{Typy kontenerów}

  \begin{itemize}
  \item \code{std::vector{<}T{>}} - wektor: ciągłość w pamięci
  \item \code{std::list{<}T{>}} - lista, bez operatora swobodnego dostępu
  \item \code{std::deque{<}T{>}} - tablica, bez ciągłości w pamięci
  \item \code{std::map{<}K, V{>}} - tablica asocjacyjna (inaczej słownik)
  \item \code{std::multimap{<}K, V{>}} - słownik, klucze zduplikowane
  \item \code{std::set{<}T{>}} - zbiór
  \item \code{std::multiset{<}T{>}} - zbiór, klucze zduplikowane
  \item \code{std::priority\_queue{<}T{>}} - kolejka priorytetowa
  \end{itemize}

  Kontenery mogą być zagnieżdżane: T może być kontenerem.

\end{frame}

%************************************************************************

\subsection{Typy kontenerów - wady i zalety}

\begin{frame}

  \frametitle{Typy kontenerów - wady i zalety}

  \begin{itemize}

  \item \code{std::vector{<}T{>}} - najlepszy, jeżeli potrzebujemy
    swobodnego dostępu (\code{operator []}), ale rzadko zmieniamy
    rozmiar wektora, wstawiamy albo usuwamy elementy.  Jest to po
    prostu tablica, którą możemy swobodnie i wygodnie zmieniać.

  \item \code{std::list{<}T{>}} - najlepsza, jeżeli często zmieniamy
    rozmiar, często dodajemy albo usuwamy elementy, wystarczy dostęp
    iteracyjny i nie jest nam potrzebny swobodny dostęp (nie ma
    \code{operator []}).

  \item \code{std::deque{<}T{>}} - najlepszy, jeżeli często zmianiamy
    rozmiar, często dodajemy albo usuwamy elementy, ale ciągle
    potrzebujemy szybkiego swobodnego dostępu (\code{operator []}
    jest).

  \end{itemize}

\end{frame}

%************************************************************************

\subsection{Iteratory}

\begin{frame}

  \frametitle{Iteratory}

  \begin{itemize}
    \item Pozwalają na dostęp do elementów kontenera.
    \item Implementacja: wskaźniki obudowane w klasy.
    \item Do funkcji przekazujemy przez wartość, nie referencję.
    \item Dla kontenera T, iterator to: \code{T::iterator}.
    \item Iterator ``const'' obiektów stałych: \code{T::const\_iterator}.
    \item Używaj iteratora ``const'', jeżeli nie modyfikujesz kontenera.
    \item Podstawowe operacje: \code{++i}, \code{i++}.
    \item Podstawowe funkcje: \code{T::begin()}, \code{T::end()}.
    \item Różne funkcje (\code{find}, \code{insert}) zwracają iteratory.
  \end{itemize}

\end{frame}

%************************************************************************

\subsection{Iteratory odwrotne}

\begin{frame}

  \frametitle{Iteratory odwrotne}

  \begin{itemize}
  \item Pozwalają na iterację od końca po elementach kontenera.
  \item Typ: \code{T::reverse\_iterator} i \code{T::const\_reverse\_iterator}
  \item Skomplikowane, bardzo trudne w użyciu i...
  \item dlatego nie mają większego znaczenia praktycznego.
  \item Przestroga: \red{lepiej nie używać!}
  \end{itemize}

\end{frame}

%************************************************************************

\subsection{Algorytmy}

\begin{frame}

  \frametitle{Algorytmy}

  \begin{itemize}
  \item Algorytmy dla różnych kontenerów:
    \begin{itemize}
    \item sortowanie elementów (lepszej implementacji nie znajdziecie),
    \item wyszukiwanie elementów,
    \item iterowanie po elementach,
    \item usuwanie i dodawanie elementów.
    \end{itemize}
  \item Działają dla różnych kontenerów, bo kontenery mają ten sam
    interfejs:
    \begin{itemize}
      \item nazwy typów (np. \code{T::data\_value}),
      \item nazwy funkcji (np. \code{T::begin()}).
    \end{itemize}
  \end{itemize}

\end{frame}

%************************************************************************

\subsection{std::pair<A, B>}

\begin{frame}

  \frametitle{std::pair<A, B>}

  \begin{itemize}
  \item \code{\#include <utility>}
  \item Para p obiektów typów A i B: \code{std::pair<A, B> p;}
  \item p.first - pierwszy element, p.second - drugi element
  \item Globalna funkcja szablonowa \code{std::make\_pair} pozwala na
    tworzenie pary bez podania typów, kompilator wywnioskuje typy
    sam:\\ \code{std::make\_pair(1, "test");}
  \item Funkcja \code{tie} pozwala na wygodne przypisanie wartości z
    pary do osobnych zmiennych:\\ \code{std::tie(f, s) = p;}
  \item Przeniesienie pary polega na przeniesieniu każdego z obiektów
    składowych.
  \item Ma zdefiniowane globalne operatory: \code{!= < == > <= >=}
  \end{itemize}

\end{frame}

%************************************************************************

\subsection{Obiekt funkcyjny}

\begin{frame}

  \frametitle{Obiekt funkcyjny}

  \begin{itemize}
  \item Obiekt funkcyjny nazywany jest też funktorem.
  \item Obiekt klasy, w której zdefiniowany jest operator wywołania
    funkcji: \code{operator()}
  \item Ten operator musi być \code{non-static} i najlepiej
    \code{const}.
  \item Ten operator można przeciążyć na wiele sposobów, ale nas
    interesuje operator, który można wykorzystać do porównania
    obiektów pewnej klasy A, elementów kontenera:\\ \code{bool
      operator () (const A \&a1, const A \&a2) const;}
  \item Kompilator będzie się starał wkompilować inline tę funkję.
  \item ZALETA: Obiektowi funkcyjnemu możemy podać dodatkowe dane w
    konstruktorze, potem używane w operatorze wywołania funkcji.
  \end{itemize}

\end{frame}

%************************************************************************

\subsection{Obiekt funkcyjny - przykład}

\begin{frame}[fragile]

  \frametitle{Obiekt funkcyjny - przykład}

\begin{lstlisting}[language=C++]
struct CMP
{
  bool m_order;
  CMP(bool order): m_order(order) {}
  bool operator () (const A &e1,
                    const A &e2) const
  {
    bool s = e1.m_text < e2.m_text;
    return m_order ? !s : s;
  }
};
\end{lstlisting}

\end{frame}

%************************************************************************

\subsection{Pętle iteracyjne po staremu}

\begin{frame}

  \frametitle{Pętle iteracyjne po staremu}

  \verbatiminput{03-example1.cc}

\end{frame}

%************************************************************************

\subsection{Pętle iteracyjne po nowemu}

\begin{frame}

  \frametitle{Pętle iteracyjne po nowemu}

  \verbatiminput{03-example2.cc}

\end{frame}

%************************************************************************

\section{Koniec}

\subsection{Podsumowanie}

\begin{frame}

  \frametitle{Podsumowanie}

  \begin{itemize}
    \item Unikać implementacji własnych struktur danych!
    \item Używać biblioteki standardowej!
    \item Kontenery biblioteki standardowej pozwalają na tworzenie
      dowolnych struktur danych.
    \item Algorytmy standardowe lepsze od własnych tandetnych
      implementacji.
  \end{itemize}

\end{frame}

%************************************************************************

\subsection{Dziękuję}

\begin{frame}[plain]

  \begin{center}
    \huge Dziękuję za uwagę.
  \end{center}

\end{frame}

\end{document}

%************************************************************************
%************************************************************************
%************************************************************************
%************************************************************************
%************************************************************************
%************************************************************************
%************************************************************************
%************************************************************************
%************************************************************************
%************************************************************************
%************************************************************************
%************************************************************************
%************************************************************************

\section{}

\begin{frame}

  \frametitle{}

  \begin{itemize}
  \item
  \end{itemize}

\end{frame}
